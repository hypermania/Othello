
#ifndef CONFIG_H
#define CONFIG_H


#include "state.h"
#include "hash.h"

#include "const.h"
//#include "io.h"




#include <unistd.h>
#include <stdlib.h>
#include <assert.h>
#include <pthread.h>
#include <math.h>
#include <limits.h>


#define LOG_BOARD_SIZE 3
#define GAME_LENGTH 60

#define ATOM(r,c) (((unsigned long int) 0x8000000000000000) >> (((r) << LOG_BOARD_SIZE) + (c)))
#define ROW(r) (0xff00000000000000 >> (r << LOG_BOARD_SIZE)) // 0 <= r < 8
#define COL(c) (0x8080808080808080 >> (c))  // 0 <= c < 8
#define DIAG(d) (0x8040201008040201 >> (d)) // 0 <= d < 7
#define RDIAG(d) ((0x0102040810204080 >> (d))  &  (~(COL(0) >> (d))) ) // 0 <= d < 7

/*
  Config specification:
  1. Need to assure that no two configs within the same set of patterns
     can be obtained via reflection along diagonals, as the patterns are
     supposed to be symmetrized.
  2. In total weight computation, reflections of a config need to be considered.
     Given a configuration, all 4 reflections of the same config are matched
     against the board, and a weight is added for each reflection.
     If a config is symmetric along some diagonal, there is no need to account for
     over-counting, since the effect will be accounted for in weight fitting.
     (The weight fitted here is half the weight of the case in which the
     symmetric config is counted only once.)
     
  Process for pattern generation:
  1. pick a set of pattern
  2. generate all variations among these patterns
  3. for each pattern, filter the configs that appear with probability < 0.01%
  4. create a scheme for storing the patterns in a table
  5. filter combinations of configs that appear with probability < 0.01%
  6. repeat
 */

typedef struct {
  /* The long ints here have 64 bits, 
     representing the board in row-major order.
     For b and w, a 0 bit denotes an empty spot, 
     and 1 denotes occupied spot. (by black or white, respectively)
   */
  /* should satisfy x&w == 0, w&b == 0, x&b==0 */
  /* board represents a config such that x^w^b == 0xff...ff */
  unsigned long int x;
  unsigned long int w;
  unsigned long int b;

} Config_store, *Config;

typedef unsigned long int Pattern;

typedef struct {
  int n;
  Config variations;
  int *matches;
} GeneratedConf;

typedef struct {
  int n;
  Pattern pattern;
  char *valid;
  Config variations;
  int *matches;
  double *weights;
} FlatConfTable;

Config create_and_init_config(void);
Config create_and_init_config_list(int length);

int init_config(Config config);
int free_config(Config config);

int check_board_as_config(Config_store conf);

int board_to_conf(Board board, Config config);

// match a maximum of n (converted) boards to a given config
// returns number of matches
int match_conf_nocreate(Config boards, Config config, int n);
int match_one_conf(Config boards, Config config);

int match_one_conf_inline(Config_store boards, Config_store config);

//int symmetric_match_conf_nocreate(Config boards, Config config, int n);
int symmetric_match_one_conf(Config boards, Config config);
int symmetric_match_one_conf_inline(Config_store boards, Config_store config);

Config_store reflect_diag(Config_store config);
Config_store reflect_rdiag(Config_store config);
Config_store reflect_bdiag(Config_store config);


/* pattern related utilities */

// 2. generate all variations among these patterns

// variation generation (step 2 in the process above)
/* return the poiner to the variations generated
   and store the total number generated in "n"
 */
Config list_variations(Pattern pattern, int *n_var);


// 3. for each pattern, filter the configs that appear with probability < 0.01%

// filter invalid configs in a set of variations
/* count the (symmetric) number of matches to "boards" for each variation;
   returns the match number table */
int *match_variations(Config variations, Config boards, int n_v, int n_b, int symmetrize);
/* returns the filtered table of configs
   stores the number of configs that passed the filter */
Config filter_variations(Config variations, int *matches, int n_v, int n_b, int *k, double threshold);


// 4. create a scheme for storing the patterns in a table

/* From a pattern and a config, compute a number that is the index
   of the config, generated by list_variations(pattern, -), that 
   is matched by the config.
   The config must be defined on set bits of the pattern.
*/
unsigned long int index_for_config(Pattern pattern, Config_store config);
// not symmetrized
int *match_std_variation_list(Pattern pattern, Config boards, int n_b);
FlatConfTable genconf_single_pattern(Pattern pattern, Config boards, int n_b, int threshold);
int init_weights_for_fct(FlatConfTable *fct);


/* pattern utilities */
// dihedral group
Pattern pattern_reflect_diag(Pattern pattern);
Pattern pattern_rotate_90(Pattern pattern);
Pattern pattern_rotate_180(Pattern pattern);
Pattern pattern_rotate_270(Pattern pattern);

/* complete the pattern set via rotation/reflection
   stores the total number of patterns generated in n_c
*/
Pattern *complete_pattern_set(Pattern *pattern, int n_p, int *n_c);


// repeat
/* "Multiplying" two sets of variations together:
   For each pair of variation, if they are compatible,
   join them to form a new variation.
   Return this set of variations.
*/
Config cross_match(Config variations_1, Config variations_2, int n_v1, int n_v2, int *total);

/* Join two configs.
   Requirement: the two configs be compatible
 */
Config_store config_join(Config_store config_1, Config_store config_2);
int match_pair_conf(Config_store config_1, Config_store config_2);


GeneratedConf genconf_for_patterns(Pattern *patterns, Config boards, int n_p, int n_b, double threshold, int symmetrize);

int ipow(int base, int exp);

#endif
